\documentclass{../industrial-development}
\graphicspath{{14-testing-of-user-interfaces/}}

\title{Тестирование пользовательских интерфейсов}
\author{Петров Алексей Анатольевич, ИВТ-21 МО}
\date{}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section{Понятие интерфейса}

\begin{frame} \frametitle{Интерфейс и его задачи}
 Интерфейс - это способ общения пользователя с~персональным компьютером, с~прикладными программами и программ между собой
\end{frame}

\lecturenotes

Часть программной системы, обеспечивающая работу интерфейса с пользователем - один из наиболее нетривиальных объектов для верификации. Нетривиальность заключается в двояком восприятии термина "пользовательский интерфейс".

С одной стороны, пользовательский интерфейс - часть программной системы. Соответственно, на пользовательский интерфейс пишутся функциональные и низкоуровневые требования, по которым затем составляются тест-требования и тест-планы. При этом, как правило, требования определяют реакцию системы на каждый ввод пользователя (при помощи клавиатуры, мыши или иного устройства ввода) и вид информационных сообщений системы, выводимых на экран, печатающее устройство или иное устройство вывода. При верификации таких требований речь идет о проверке функциональной полноты пользовательского интерфейса - насколько реализованные функции соответствуют требованиям, корректно ли выводится информация на экран.

С другой стороны, пользовательский интерфейс - "лицо" системы, и от его продуманности зависит эффективность работы пользователя с системой. Факторы, влияющие на эффективность работы, слабо поддаются формализации в виде конкретных требований к отдельным элементам, однако должны быть учтены в виде общих рекомендаций и принципов построения пользовательского интерфейса программной системы. Проверка интерфейса на эффективность человеко-машинного взаимодействия получила название проверки удобства использования ( usability verification ; в русскоязычной литературе в качестве перевода термина usability часто используют слово "практичность").


\section{Требования к пользовательскому интерфейсу}

\begin{frame} \frametitle{Виды требований к интерфейсу}
  \begin{block}{Внешний вид}
   Требования к внешнему виду пользовательского интерфейса и формам взаимодействия с пользователем
  \end{block}
  \begin{block}{Внутренний функционал}
   Требования по доступу к внутренней функциональности системы при помощи пользовательского интерфейса
  \end{block}
\end{frame}

\lecturenotes

Требования к пользовательскому интерфейсу могут быть разбиты на две группы:

требования к внешнему виду пользовательского интерфейса и формам взаимодействия с пользователем;
требования по доступу к внутренней функциональности системы при помощи пользовательского интерфейса.
Другими словами, первая группа требований описывает взаимодействие подсистемы интерфейса с пользователем, а вторая - с внутренней логикой системы.

\begin{frame} \frametitle{Требования к внешнему виду}
  \begin{block}{Размещение элементов}
   Общие принципы размещения элементов пользовательского интерфейса
  \end{block}
Данные требования могут определять общие принципы размещения элементов пользовательского интерфейса или~требования к размещению конкретных элементов
\end{frame}

\lecturenotes

Данные требования могут определять общие принципы размещения элементов пользовательского интерфейса или требования к размещению конкретных элементов. Например, общие требования по размещению элементов на графической экранной форме могут выглядеть следующим образом:

Каждое окно приложения должно быть разбито на три части: строка меню, рабочая область и статусная строка. Строка меню должна быть горизонтальной и прижатой к верхней части окна, статусная строка должна быть горизонтальной и прижатой к нижней части окна, рабочая область должна находиться между строкой меню и статусной строкой и занимать всю оставшуюся площадь окна.

При тестировании данного требования достаточно определить, что в каждом окне системы действительно присутствуют три части, которые расположены и прижаты согласно требованиям даже при изменении размеров окна, его сворачивании/разворачивании, перемещении по экрану, при перекрытии его другими окнами.

Примером требований по размещению конкретного элемента может служить следующее:

Кнопка "Начать передачу" должна находиться непосредственно под строкой меню в левой части рабочей области окна.

При тестировании такого требования также необходимо определить, сохраняется ли расположение элемента при изменении размера окна, а также при использовании элемента (в данном случае - при нажатии).

\begin{frame} \frametitle{Требования к внешнему виду}
  \begin{block}{Вводимые сообщения}
   Содержанию и оформлению выводимых сообщений
  \end{block}
Требования выводимых сообщений определяют текст сообщений, выводимых системой, его шрифтовое и~цветовое оформление
\end{frame}

\lecturenotes

Требования к содержанию и оформлению выводимых сообщений определяют текст сообщений, выводимых системой, его шрифтовое и цветовое оформление. Также часто в таких требованиях определяется, в каких случаях выводится то или иное сообщение.

Так, например, для тестирования требования

Сообщение "Невозможно открыть файл" должно выводиться в статусную строку прижатым к левому краю, красным цветом, полужирным шрифтом в случае недоступности открываемого файла по чтению.

необходимо проверить, что при возникновении указанной ситуации сообщение действительно выводится согласно требованиям.

Однако в случае тестирования требования вида

Сообщения об ошибках должны выводиться в статусную строку прижатыми к левому краю красным цветом полужирным шрифтом.

необходимо проверять форматы всех возможных сообщений об ошибках программы во всех возможных ошибочных ситуациях. Таким образом, очевидно, что при тестировании пользовательского интерфейса не всегда можно однозначно определить количество тестовых примеров, которые понадобятся для тестирования требования. Эта проблема вызвана тем, что требования к пользовательскому интерфейсу зачастую кажутся слишком очевидными для их точной формулировки. Эта неконкретность требований и вызывает большое количество тестов для каждого требования.

\begin{frame} \frametitle{Требования к внешнему виду}
  \begin{block}{Формат ввода}
  Данная группа требований определяет, в каком виде информация поступает от пользователя в систему
  \end{block}
  \begin{block}{Реакция на ввод}
   Данный тип требований определяет связь внутренней логики системы и интерфейсных элементов
  \end{block}
\end{frame}

\lecturenotes

Требования к форматам ввода
Данная группа требований определяет, в каком виде информация поступает от пользователя в систему. При этом кроме собственно требований, определяющих корректный формат, к этой группе относятся требования, определяющие реакцию системы на некорректный ввод. Для проверки таких требований необходимо проверять как корректный ввод, так и некорректный. Желательно при этом разбивать различные варианты ввода на классы эквивалентности (как минимум на два - корректные и некорректные).

Ко второй группе относятся следующие типы требований.

Требования к реакции системы на ввод пользователя
Данный тип требований определяет связь внутренней логики системы и интерфейсных элементов. Например,

При нажатии кнопки "Сброс" значение таймера синхронизации передачи должно сбрасываться в 0.

Для проверки такого требования в тестовом примере должно быть сымитировано нажатие на кнопку "Сброс", после чего должна проводиться проверка значения таймера. Однако некоторые требования определяют в качестве реакции системы не то, как меняется ее внутреннее состояние, а реакцию пользовательского интерфейса. Например, в требовании

При нажатии кнопки "Отложенный сброс" должно выводиться окно "Ввод значения времени для отложенного сброса".

в качестве реакции на использование одного интерфейсного элемента определяется появление другого интерфейсного элемента. Такие требования проверяются при помощи имитации ввода пользователя и анализа появляющихся интерфейсных элементов.

\begin{frame} \frametitle{Требования к внешнему виду}
  \begin{block}{Отклик на команды}
  Время отклика системы на различные пользовательские операции
  \end{block}
Предельное время отклика должно быть указано в требованиях и пользовательской документации
\end{frame}

\lecturenotes

Требования к времени отклика на команды пользователя
В качестве отдельного типа требований можно выделить требования к времени отклика системы на различные пользовательские операции. Это связано с тем, что подсознательно пользователь воспринимает операции продолжительностью более 1 секунды как длительные. Если в этот момент система не сообщает пользователю о том, что она выполняет какую-либо операцию, пользователь начнет считать, что система зависла или работает в неверном режиме. В связи с этим либо каждое предельное время отклика должно быть указано в требованиях и пользовательской документации, либо во время длительных операций должны выводиться информационные сообщения (например, индикатор прогресса). Значения предельного времени и равномерность увеличения значений индикатора прогресса должны проверяться соответствующими тестами.

\section{Понятие тестирования пользовательского интерфейса}

\begin{frame} \frametitle{Виды пользовательских интерфейсов}
  \begin{itemize}
  \item Командный интерфейс
  \item Графический интерфейс
  \item SILK-интерфейс
  \end{itemize}
\end{frame}

\lecturenotes

В информационных технологиях конечного пользователя важное значение имеет пользовательский интерфейс – совокупность элементов, позволяющих пользователю управлять работой программы или вычислительной системы и получать требуемые результаты. Фактически, пользовательский интерфейс – это канал, по которому осуществляется взаимодействие пользователя и программы. Пользовательский интерфейс реализует работу человека на персональном компьютере посредством элементов взаимодействия.

Элемент взаимодействия – это элемент пользовательского интерфейса, с помощью которого пользователь непосредственно взаимодействует с программой или вычислительной системой.

Различают активные и пассивные элементы взаимодействия.

Пассивный элемент взаимодействия – это элемент пользовательского интерфейса, через который пользователь не имеет прямого доступа к системным или программным ресурсам, т. е. не может управлять или изменять эти ресурсы напрямую и непосредственно.

К пассивным элементам взаимодействия относятся информационные сообщения, подсказки и т. д.

Активный элемент взаимодействия – это элемент пользовательского интерфейса, через который пользователь имеет прямой доступ к системным и программным ресурсам с возможностью непосредственного управления и изменения их.

К активным элементам взаимодействия относятся команды управления системными настройками и программными ресурсами, средства конфигурации системы, команды работы с файловыми системами.

Развитие пользовательских интерфейсов происходило по двум направлениям:

Различают два основных уровня представления данных в ЭВМ:

– физический уровень представления данных;

– логический уровень представления данных.

Согласно общепринятой классификации, существующие на практике интерфейсы можно разделить на следующие виды:

– командный интерфейс;

– графический интерфейс;

– SILK-интерфейс.

\begin{frame} \frametitle{Командный интерфейс}
 Взаимодействие с ПК посредством \alert{командной строки}, в которую вводятся команды определенного формата
\end{frame}

\lecturenotes

Командный интерфейс. Одним из основных и наиболее старых является интерфейс командной строки. Командный (командно-строчный) интерфейс получил наибольшее развитие во времена расцвета больших многопользовательских систем с алфавитно-цифровыми дисплеями. Он характеризуется тем, что пользователь осуществляет взаимодействие с ЭВМ посредством командной строки, в которую вводятся команды определенного формата, а затем передаются к исполнению.

\begin{frame} \frametitle{SILK}
 \alert{SILK}-интерфейс (Speech, Image, Language, Knowledge — речь, образ, язык, знание)
\end{frame}

\lecturenotes

SILK-интерфейс (Speech, Image, Language, Knowledge — речь, образ, язык, знание). В настоящее время SILK-интерфейс существует лишь как «голосовой» (если не считать биометрических интерфейсов, применяющихся не для управления компьютером, а лишь для идентификации пользователя). Это очень перспективное направление по той причине, что вводить информацию с голоса – самый быстрый и удобный способ. Но его практические реализации пока не стали доминирующими, т.к. качество распознавания устной речи пока далеко от идеала.

\begin{frame} \frametitle{GUI}
 \alert{Графический интерфейс пользователя} — это графическая среда организации взаимодействия пользователя с~вычислительной системой, и использование основных элементов диалога пользователя с ПК
\end{frame}

\lecturenotes

Графический интерфейс пользователя — это графическая среда организации взаимодействия пользователя с вычислительной системой, предполагающая стандартное использование основных элементов диалога пользователя с ЭВМ.

К графическим интерфейсам относят все оконные чисто графические системы — это Windows, оболочки для UNIX — X-Window, Photon из ОС QNX, Aqua из MacOS X. Основное преимущество его использования в операционной системе (далее — ОС) заключается в том, что он позволяет создавать одинаковые графические изображения для всех устройств, поддерживаемых ОС, реализуя принцип WYSIWYG (от англ. What You See Is What You Get — что видим, то и получаем).

Графический интерфейс позволяет управлять поведением вычислительной системы через визуальные элементы управления: окна, списки, кнопки, гиперссылки и полосы прокрутки. Он включает такие понятия, как: рабочий стол, окна, пиктограммы, элементы графического интерфейса, манипуляция указывающим устройством (мышь). Эти визуальные элементы создаются, отображаются и обрабатываются с помощью графических приложений.

\begin{frame} \frametitle{Виды тестирования}
  \begin{enumerate}
  \item Исследовательское
  \item Оценочное
  \item Валидационное
  \item Сравнительное
  \end{enumerate}
\end{frame}

\lecturenotes

Тестирование удобства использования пользовательского интерфейса, вообще говоря, не относится к классическим методам тестирования программных систем. Специалист по тестированию пользовательского интерфейса должен сочетать в себе знания как в области программной инженерии, так и в физиологии, психологии и эргономике.
ыделяют следующие этапы тестирования удобства использования пользовательского интерфейса.

Исследовательское - проводится после формулирования требований к системе и разработки прототипа интерфейса. Основная цель на этом этапе - провести высокоуровневое обследование интерфейса и выяснить, позволяет ли он с достаточной степенью эффективности решать задачи пользователя.
Оценочное - проводится после разработки низкоуровневых требований и детализированного прототипа пользовательского интерфейса. Оценочное тестирование углубляет исследовательское и имеет ту же цель. На данном этапе уже проводятся количественные измерения характеристик пользовательского интерфейса: измеряются количество обращений к системе помощи по отношению к количеству совершенных операций, количество ошибочных операций, время устранения последствий ошибочных операций и т.п.
Валидационное - проводится ближе к этапу завершения разработки. На этом этапе проводится анализ соответствия интерфейса программной системы стандартам, регламентирующим вопросы удобства интерфейса (например ISO 13407, ISO 9126), проводится общее тестирование всех компонент пользовательского интерфейса с точки зрения конечного пользователя. Под компонентами интерфейса здесь понимается как его программная реализация, так и система помощи и руководство пользователя. Также на данном этапе проверяется отсутствие дефектов удобства использования интерфейса, выявленных на предыдущих этапах.
Сравнительное - данный вид тестирования может проводиться на любом этапе разработки интерфейса. В ходе сравнительного тестирования сравниваются два или более вариантов реализации пользовательского интерфейса.


\begin{frame} \frametitle{Функционал тестирования}
  \begin{enumerate}
  \item Анализ требований к пользовательскому интерфейсу
  \item Разработка тест-требований и тест-планов для~проверки пользовательского интерфейса
  \item Выполнение тестовых примеров и сбор информации о~выполнении тестов
  \item Определение полноты покрытия пользовательского интерфейса требованиями
  \item Cоставление отчетов о проблемах
  \end{enumerate}
\end{frame}

\lecturenotes

Функциональное тестирование пользовательского интерфейса состоит из пяти фаз:

анализ требований к пользовательскому интерфейсу;
разработка тест-требований и тест-планов для проверки пользовательского интерфейса;
выполнение тестовых примеров и сбор информации о выполнении тестов;
определение полноты покрытия пользовательского интерфейса требованиями;
составление отчетов о проблемах в случае несовпадения поведения системы и требований либо в случае отсутствия требований на отдельные интерфейсные элементы.
Все эти фазы точно такие же, как и в случае тестирования любого другого компонента программной системы. Отличия заключаются в трактовке некоторых терминов в применении к пользовательскому интерфейсу и в особенностях автоматизированного сбора информации на каждой фазе.

Так, тест-планы для проверки пользовательского интерфейса, как правило, представляют собой сценарии, описывающие действия пользователя при работе с системой. Сценарии могут быть записаны либо на естественном языке, либо на формальном языке какой-либо системы автоматизации пользовательского интерфейса. Выполнение тестов при этом производится либо оператором в ручном режиме, либо системой, которая эмулирует поведение оператора.

При сборе информации о выполнении тестовых примеров обычно применяются технологии анализа выводимых на экран форм и их элементов (в случае графического интерфейса) или выводимого на экран текста (в случае текстового), а не проверка значений тех или иных переменных, устанавливаемых программной системой.

Под полнотой покрытия пользовательского интерфейса понимается то, что в результате выполнения всех тестовых примеров каждый интерфейсный элемент был использован хотя бы один раз во всех доступных режимах.

Отчеты о проблемах в пользовательском интерфейсе могут включать в себя как описания несоответствий требований и реального поведения системы, так и описания проблем в требованиях к пользовательскому интерфейсу. Основной источник проблем в этих требованиях - их тестонепригодность, вызванная расплывчатостью формулировок и неконкретностью.

\section{Методы проведения тестирования пользовательского интерфейса}

\begin{frame} \frametitle{Методы тестирования}
  \begin{block}{Ручное}
   При непосредственном участии оператора
  \end{block}
  \begin{block}{Автоматическое}
   Выполнение тестов и сценариев
  \end{block}
\end{frame}

\begin{frame} \frametitle{Ручное тестирование}
\alert{Ручное тестирование} пользовательского интерфейса проводится тестировщиком-оператором, который руководствуется в своей работе описанием тестовых примеров в виде набора сценариев
\end{frame}

\lecturenotes

Ручное тестирование

Ручное тестирование пользовательского интерфейса проводится тестировщиком-оператором, который руководствуется в своей работе описанием тестовых примеров в виде набора сценариев. Каждый сценарий включает в себя перечисление последовательности действий, которые должен выполнить оператор, и описание важных для анализа результатов тестирования ответных реакций системы, отражаемых в пользовательском интерфейсе. Типичная форма записи сценария для проведения ручного тестирования - таблица, в которой в одной колонке описаны действия (шаги сценария), в другой - ожидаемая реакция системы, а третья предназначена для записи того, совпала ли ожидаемая реакция системы с реальной и перечисления несовпадений.

Ручное тестирование пользовательского интерфейса удобно тем, что контроль корректности интерфейса проводится человеком, т.е. основным "потребителем" данной части программной системы. К тому же при чисто косметических изменениях в интерфейсах системы, не отраженных в требованиях (например, при перемещении кнопок управления на 10 пикселей влево), анализ успешности прохождения теста будет выполняться не по формальным признакам, а согласно человеческому восприятию.

При этом ручное тестирование имеет и существенный недостаток - для его проведения требуются значительные человеческие и временные ресурсы. Особенно сильно этот недостаток проявляется при проведении регрессионного тестирования и вообще любого повторного тестирования - на каждой итерации повторного тестирования пользовательского интерфейса требуется участие тестировщика-оператора. В связи с этим в последнее десятилетие получили распространение средства автоматизации тестирования пользовательского интерфейса, снижающие нагрузку на тестировщика-оператора.

\begin{frame} \frametitle{Автоматическое тестирование}
\alert{Автоматизации тестирования} пользовательского интерфейса - использование программных инструментов, эмулирующих поведение тестировщика-оператора при ручном тестировании пользовательского интерфейса
\end{frame}

\lecturenotes

Сценарии на формальных языках
Естественный способ автоматизации тестирования пользовательского интерфейса - использование программных инструментов, эмулирующих поведение тестировщика-оператора при ручном тестировании пользовательского интерфейса.

Такие инструменты используют в качестве входной информации сценарии тестовых примеров, записанные на некотором формальном языке, операторы которого соответствуют действиям пользователя - вводу команд, перемещению курсора, активизации пунктов меню и других интерфейсных элементов.

При выполнении автоматизированного теста инструмент тестирования имитирует действия пользователя, описанные в сценарии, и анализирует интерфейсную реакцию системы. Для определения ожидаемого состояния пользовательского интерфейса здесь могут применяться различные методы - либо анализ снимков экрана и сравнение их с эталонными, либо доступ к данным интерфейсных элементов средствами операционной системы (например, доступ ко всем кнопкам окна по их дескрипторам и получение значений текста).

И при передаче информации в тестируемый интерфейс, и при получении информации для анализа могут использоваться два способа доступа к элементам интерфейса:

позиционный, при котором доступ к элементу осуществляется при помощи задания его абсолютных (относительно экрана) или относительных (относительно окна) координат и размеров;
по идентификатору, при котором доступ к элементу осуществляется при помощи получения интерфейсного элемента при помощи его уникального идентификатора в пределах окна.
При внесении изменений в пользовательский интерфейс при использовании первого метода в результате проведения регрессионного тестирования будет выявлено большое количество не прошедших тестов - достаточно изменения местоположения одного ключевого интерфейсного элемента, как все сценарии начнут работать неверно. Соответственно при таком методе автоматизации тестирования необходимо менять значительную часть сценариев в системе тестов при каждом изменении интерфейса системы. Такой метод автоматизации тестирования подходит для систем с устоявшимся и редко изменяемым интерфейсом.

Второй метод автоматизации тестирования более устойчив к изменению расположения интерфейсных элементов, но изменения тестовых примеров могут потребоваться и здесь в случае изменения логики работы интерфейсных элементов. Например, пусть в первой версии системы при нажатии на кнопку "Передать данные" передача данных начиналась сразу и выводилось окно с индикатором прогресса. Сценарий тестового примера в этом случае включает в себя имитацию нажатия на кнопку и обращение к индикатору прогресса для получения значения прогресса в процентах.

\begin{frame} \frametitle{Ошибки тестирования}
\begin{itemize}
\item Неправильное использование интерфейсов
\item Неправильное понимание интерфейсов
\item Ошибки синхронизации
\end{itemize}
\end{frame}

\lecturenotes

Ошибки в интерфейсах являются наиболее распространенными типами ошибок в сложных системах и делятся на три класса.

1. Неправильное использование интерфейсов. Компонент вызывает другой компонент и совершает ошибку при использовании его интерфейса. Данный тип ошибки особенно распространен в параметрических интерфейсах; например, параметры могут иметь неправильный тип, следовать в неправильном порядке или же иметь неверное количество параметров.

2. Неправильное понимание интерфейсов. Вызывающий компонент, в который заложена неправильная интерпретация спецификации интерфейса вызываемого компонента, предполагает определенное поведение этого компонента. Если поведение вызываемого компонента не совпадает с ожидаемым, поведение вызывающего компонента становится непредсказуемым. Например, если программа бинарного поиска вызывается для поиска заданного элемента в неупорядоченном массиве, то в работе программы произойдет сбой.

3. Ошибки синхронизации. Такие ошибки встречаются в системах реального времени, где используются интерфейсы разделяемой памяти или передачи сообщений. Подсистема – производитель данных и подсистема – потребитель данных могут работать с разной скоростью. Если при проектировании интерфейса не учитывать этот фактор, потребитель может, например, получить доступ к устаревшим данным, потому что производитель к тому моменту еще не успел обновить совместно используемые данные.

Тестирование дефектов интерфейсов сложно, поскольку некоторые ошибки могут проявиться только в необычных условиях. Например, пусть некий объект реализует очередь в виде структуры списка фиксированного размера. Вызывающий его объект при вводе очередного элемента не проверяет переполнение очереди, так как предполагает, что очередь реализована как структура неограниченного размера. Такую ситуацию можно обнаружить только во время выполнения специальных тестов: специально вызывается переполнение очереди, которое приводит к непредсказуемому поведению объекта.

Другая проблема может возникнуть из-за взаимодействий между ошибками в разных программных модулях или объектах. Ошибки в одном объекте можно выявить только тогда, когда поведение другого объекта становится непредсказуемым. Например, для получения сервиса один объект вызывает другой объект и полагает, что полученный ответ правильный. Если объект неправильно понимает вычисленные значения, возвращаемое значение может быть достоверным, но неправильным.


\begin{frame} \frametitle{}
"Для большинства интерфейсов ситуация не является симметричной, и порядок (существительное-глагол или~глагол-существительное) имеет большое значение с~точки зрения юзабилити интерфейса."
\end{frame}


\begin{thebibliography}{99}

%Информацию собирал с нескольких мест на один слайд, поэтому указал списком, а не метками

\href{https://refdb.ru/look/1330949.html}
\href{https://www.intuit.ru/studies/courses/1040/209/lecture/5418?page=3}
\href{http://www.bestreferat.ru/referat-379140.html#_Toc233721005}
\href{https://refdb.ru/look/1330949.html}
\href{https://megalektsii.ru/s8890t5.html}
\end{thebibliography}

\end{document}
%%% Local Variables: 
%%% mode: TeX-pdf
%%% TeX-master: t
%%% End: 
